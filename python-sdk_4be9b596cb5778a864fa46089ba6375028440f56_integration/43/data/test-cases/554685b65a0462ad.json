{"uid":"554685b65a0462ad","name":"test_streaming_select[core]","fullName":"tests.integration.dbapi.sync.V2.test_streaming#test_streaming_select","historyId":"d47e3d4e99c3c8a1ca9e57bf19febde1","time":{"start":1751992255970,"stop":1751992255994,"duration":24},"description":"Select handles all data types properly.","descriptionHtml":"<p>Select handles all data types properly.</p>\n","status":"broken","statusMessage":"httpx.ConnectError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)","statusTrace":"@contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.KeepaliveTransport object at 0x7f6d1d13bc10>\nrequest = <Request('POST', 'https://localhost/?database=firebolt&timezone=Asia%2FCalcutta')>\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n    \n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n>           resp = self._pool.handle_request(req)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:236: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ConnectionPool [Requests: 0 active, 0 queued | Connections: 0 active, 0 idle]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"pool\", None)\n    \n        with self._optional_thread_lock:\n            # Add the incoming request to our request queue.\n            pool_request = PoolRequest(request)\n            self._requests.append(pool_request)\n    \n        try:\n            while True:\n                with self._optional_thread_lock:\n                    # Assign incoming requests to available connections,\n                    # closing or creating new connections as required.\n                    closing = self._assign_requests_to_connections()\n                self._close_connections(closing)\n    \n                # Wait until this request has an assigned connection.\n                connection = pool_request.wait_for_connection(timeout=timeout)\n    \n                try:\n                    # Send the request on the assigned connection.\n                    response = connection.handle_request(\n                        pool_request.request\n                    )\n                except ConnectionNotAvailable:\n                    # In some cases a connection may initially be available to\n                    # handle a request, but then become unavailable.\n                    #\n                    # In this case we clear the connection and try again.\n                    pool_request.clear_connection()\n                else:\n                    break  # pragma: nocover\n    \n        except BaseException as exc:\n            with self._optional_thread_lock:\n                # For any exception or cancellation we remove the request from\n                # the queue, and then re-assign requests to connections.\n                self._requests.remove(pool_request)\n                closing = self._assign_requests_to_connections()\n    \n            self._close_connections(closing)\n>           raise exc from None\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection_pool.py:256: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ConnectionPool [Requests: 0 active, 0 queued | Connections: 0 active, 0 idle]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"pool\", None)\n    \n        with self._optional_thread_lock:\n            # Add the incoming request to our request queue.\n            pool_request = PoolRequest(request)\n            self._requests.append(pool_request)\n    \n        try:\n            while True:\n                with self._optional_thread_lock:\n                    # Assign incoming requests to available connections,\n                    # closing or creating new connections as required.\n                    closing = self._assign_requests_to_connections()\n                self._close_connections(closing)\n    \n                # Wait until this request has an assigned connection.\n                connection = pool_request.wait_for_connection(timeout=timeout)\n    \n                try:\n                    # Send the request on the assigned connection.\n>                   response = connection.handle_request(\n                        pool_request.request\n                    )\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection_pool.py:236: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        try:\n            with self._request_lock:\n                if self._connection is None:\n                    stream = self._connect(request)\n    \n                    ssl_object = stream.get_extra_info(\"ssl_object\")\n                    http2_negotiated = (\n                        ssl_object is not None\n                        and ssl_object.selected_alpn_protocol() == \"h2\"\n                    )\n                    if http2_negotiated or (self._http2 and not self._http1):\n                        from .http2 import HTTP2Connection\n    \n                        self._connection = HTTP2Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                    else:\n                        self._connection = HTTP11Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n        except BaseException as exc:\n            self._connect_failed = True\n>           raise exc\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        try:\n            with self._request_lock:\n                if self._connection is None:\n>                   stream = self._connect(request)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def _connect(self, request: Request) -> NetworkStream:\n        timeouts = request.extensions.get(\"timeout\", {})\n        sni_hostname = request.extensions.get(\"sni_hostname\", None)\n        timeout = timeouts.get(\"connect\", None)\n    \n        retries_left = self._retries\n        delays = exponential_backoff(factor=RETRIES_BACKOFF_FACTOR)\n    \n        while True:\n            try:\n                if self._uds is None:\n                    kwargs = {\n                        \"host\": self._origin.host.decode(\"ascii\"),\n                        \"port\": self._origin.port,\n                        \"local_address\": self._local_address,\n                        \"timeout\": timeout,\n                        \"socket_options\": self._socket_options,\n                    }\n                    with Trace(\"connect_tcp\", logger, request, kwargs) as trace:\n                        stream = self._network_backend.connect_tcp(**kwargs)\n                        trace.return_value = stream\n                else:\n                    kwargs = {\n                        \"path\": self._uds,\n                        \"timeout\": timeout,\n                        \"socket_options\": self._socket_options,\n                    }\n                    with Trace(\n                        \"connect_unix_socket\", logger, request, kwargs\n                    ) as trace:\n                        stream = self._network_backend.connect_unix_socket(\n                            **kwargs\n                        )\n                        trace.return_value = stream\n    \n                if self._origin.scheme in (b\"https\", b\"wss\"):\n                    ssl_context = (\n                        default_ssl_context()\n                        if self._ssl_context is None\n                        else self._ssl_context\n                    )\n                    alpn_protocols = [\"http/1.1\", \"h2\"] if self._http2 else [\"http/1.1\"]\n                    ssl_context.set_alpn_protocols(alpn_protocols)\n    \n                    kwargs = {\n                        \"ssl_context\": ssl_context,\n                        \"server_hostname\": sni_hostname\n                        or self._origin.host.decode(\"ascii\"),\n                        \"timeout\": timeout,\n                    }\n                    with Trace(\"start_tls\", logger, request, kwargs) as trace:\n>                       stream = stream.start_tls(**kwargs)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection.py:156: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore._backends.sync.SyncStream object at 0x7f6d1d138cd0>\nssl_context = <truststore._api.SSLContext object at 0x7f6d1d269940>\nserver_hostname = 'localhost', timeout = 60\n\n    def start_tls(\n        self,\n        ssl_context: ssl.SSLContext,\n        server_hostname: str | None = None,\n        timeout: float | None = None,\n    ) -> NetworkStream:\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n>       with map_exceptions(exc_map):\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_backends/sync.py:154: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7f6d1d13b3d0>\ntyp = <class 'ssl.SSLCertVerificationError'>\nvalue = SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)')\ntraceback = <traceback object at 0x7f6d1d30e700>\n\n    def __exit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n>               self.gen.throw(typ, value, traceback)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/contextlib.py:153: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmap = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE786\n            for from_exc, to_exc in map.items():\n                if isinstance(exc, from_exc):\n>                   raise to_exc(exc) from exc\nE                   httpcore.ConnectError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_exceptions.py:14: ConnectError\n\nThe above exception was the direct cause of the following exception:\n\nconnection = <firebolt.db.connection.Connection object at 0x7f6d1d2a9230>\nall_types_query = 'select 1 as uint8, -1 as int_8, 257 as uint16, -257 as int16, 80000 as uint32, -80000 as int32, 30000000000 as uint64...232.123459999990457054844258706536\\' as decimal(38,30)) as \"decimal\", null as \"nullable\", \\'abc123\\'::bytea as \"bytea\"'\nall_types_query_description = [Column(name='uint8', type_code=<class 'int'>, display_size=None, internal_size=None, precision=None, scale=None, null...int32', type_code=<class 'int'>, display_size=None, internal_size=None, precision=None, scale=None, null_ok=None), ...]\nall_types_query_response = [[1, -1, 257, -257, 80000, -80000, ...]]\ntimezone_name = 'Asia/Calcutta'\n\n    def test_streaming_select(\n        connection: Connection,\n        all_types_query: str,\n        all_types_query_description: List[Column],\n        all_types_query_response: List[ColType],\n        timezone_name: str,\n    ) -> None:\n        \"\"\"Select handles all data types properly.\"\"\"\n        with connection.cursor() as c:\n            # For timestamptz test\n>           assert (\n                c.execute(f\"SET timezone={timezone_name}\") == -1\n            ), \"Invalid set statment row count\"\n\ntests/integration/dbapi/sync/V2/test_streaming.py:24: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/common/cursor/decorators.py:24: in inner\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:338: in execute\n    self._do_execute(query, params_list, skip_parsing, timeout=timeout_seconds)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:238: in _do_execute\n    self._execute_single_query(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:263: in _execute_single_query\n    self._validate_set_parameter(query, timeout_controller.remaining())\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:168: in _validate_set_parameter\n    resp = self._api_request(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:159: in _api_request\n    return self._client.send(req, stream=True)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:926: in send\n    response = self._send_handling_auth(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:954: in _send_handling_auth\n    response = self._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/client/client.py:123: in _send_handling_redirects\n    return super()._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:991: in _send_handling_redirects\n    response = self._send_single_request(request)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:1027: in _send_single_request\n    response = transport.handle_request(request)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:235: in handle_request\n    with map_httpcore_exceptions():\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/contextlib.py:153: in __exit__\n    self.gen.throw(typ, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:\n            mapped_exc = None\n    \n            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():\n                if not isinstance(exc, from_exc):\n                    continue\n                # We want to map to the most specific exception we can find.\n                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to\n                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.\n                if mapped_exc is None or issubclass(to_exc, mapped_exc):\n                    mapped_exc = to_exc\n    \n            if mapped_exc is None:  # pragma: no cover\n                raise\n    \n            message = str(exc)\n>           raise mapped_exc(message) from exc\nE           httpx.ConnectError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:89: ConnectError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":1,"retriesStatusChange":true,"beforeStages":[{"name":"service_secret","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"database_name","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"engine_name","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"service_id","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"auth","time":{"start":1751992252368,"stop":1751992252436,"duration":68},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"api_endpoint","time":{"start":1751992252436,"stop":1751992252436,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_url","time":{"start":1751992252436,"stop":1751992252437,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_auth","time":{"start":1751992252436,"stop":1751992252436,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"account_name","time":{"start":1751992252436,"stop":1751992252436,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"connection","time":{"start":1751992255966,"stop":1751992255969,"duration":3},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"all_types_query_response","time":{"start":1751992255969,"stop":1751992255969,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"timezone_name","time":{"start":1751992255969,"stop":1751992255969,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"timezone_offset_seconds","time":{"start":1751992255969,"stop":1751992255969,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"all_types_query_description","time":{"start":1751992255969,"stop":1751992255969,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"all_types_query","time":{"start":1751992255969,"stop":1751992255969,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"afterStages":[{"name":"connection::0","time":{"start":1751992256096,"stop":1751992256096,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"parentSuite","value":"tests.integration.dbapi.sync.V2"},{"name":"suite","value":"test_streaming"},{"name":"host","value":"pkrvmbietmlfzoi"},{"name":"thread","value":"3786-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.integration.dbapi.sync.V2.test_streaming"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"connection","value":"'core'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[{"uid":"6dcc5360eacd8a69","status":"passed","time":{"start":1751992248403,"stop":1751992248447,"duration":44}}],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"554685b65a0462ad.json","parameterValues":["'core'"]}