{"uid":"4717e24cd961d205","name":"test_parameterized_query[core]","fullName":"tests.integration.dbapi.sync.V2.test_queries#test_parameterized_query","historyId":"eb65e665969ecf249b228288c6323548","time":{"start":1751992254857,"stop":1751992254881,"duration":24},"description":"Query parameters are handled properly.","descriptionHtml":"<p>Query parameters are handled properly.</p>\n","status":"broken","statusMessage":"httpx.ConnectError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)","statusTrace":"@contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:72: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.KeepaliveTransport object at 0x7f6d1cf7e800>\nrequest = <Request('POST', 'https://localhost/?database=firebolt&output_format=JSON_Compact')>\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n    \n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n>           resp = self._pool.handle_request(req)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:236: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ConnectionPool [Requests: 0 active, 0 queued | Connections: 0 active, 0 idle]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"pool\", None)\n    \n        with self._optional_thread_lock:\n            # Add the incoming request to our request queue.\n            pool_request = PoolRequest(request)\n            self._requests.append(pool_request)\n    \n        try:\n            while True:\n                with self._optional_thread_lock:\n                    # Assign incoming requests to available connections,\n                    # closing or creating new connections as required.\n                    closing = self._assign_requests_to_connections()\n                self._close_connections(closing)\n    \n                # Wait until this request has an assigned connection.\n                connection = pool_request.wait_for_connection(timeout=timeout)\n    \n                try:\n                    # Send the request on the assigned connection.\n                    response = connection.handle_request(\n                        pool_request.request\n                    )\n                except ConnectionNotAvailable:\n                    # In some cases a connection may initially be available to\n                    # handle a request, but then become unavailable.\n                    #\n                    # In this case we clear the connection and try again.\n                    pool_request.clear_connection()\n                else:\n                    break  # pragma: nocover\n    \n        except BaseException as exc:\n            with self._optional_thread_lock:\n                # For any exception or cancellation we remove the request from\n                # the queue, and then re-assign requests to connections.\n                self._requests.remove(pool_request)\n                closing = self._assign_requests_to_connections()\n    \n            self._close_connections(closing)\n>           raise exc from None\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection_pool.py:256: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <ConnectionPool [Requests: 0 active, 0 queued | Connections: 0 active, 0 idle]>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        timeouts = request.extensions.get(\"timeout\", {})\n        timeout = timeouts.get(\"pool\", None)\n    \n        with self._optional_thread_lock:\n            # Add the incoming request to our request queue.\n            pool_request = PoolRequest(request)\n            self._requests.append(pool_request)\n    \n        try:\n            while True:\n                with self._optional_thread_lock:\n                    # Assign incoming requests to available connections,\n                    # closing or creating new connections as required.\n                    closing = self._assign_requests_to_connections()\n                self._close_connections(closing)\n    \n                # Wait until this request has an assigned connection.\n                connection = pool_request.wait_for_connection(timeout=timeout)\n    \n                try:\n                    # Send the request on the assigned connection.\n>                   response = connection.handle_request(\n                        pool_request.request\n                    )\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection_pool.py:236: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        try:\n            with self._request_lock:\n                if self._connection is None:\n                    stream = self._connect(request)\n    \n                    ssl_object = stream.get_extra_info(\"ssl_object\")\n                    http2_negotiated = (\n                        ssl_object is not None\n                        and ssl_object.selected_alpn_protocol() == \"h2\"\n                    )\n                    if http2_negotiated or (self._http2 and not self._http1):\n                        from .http2 import HTTP2Connection\n    \n                        self._connection = HTTP2Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                    else:\n                        self._connection = HTTP11Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n        except BaseException as exc:\n            self._connect_failed = True\n>           raise exc\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection.py:101: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        try:\n            with self._request_lock:\n                if self._connection is None:\n>                   stream = self._connect(request)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection.py:78: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def _connect(self, request: Request) -> NetworkStream:\n        timeouts = request.extensions.get(\"timeout\", {})\n        sni_hostname = request.extensions.get(\"sni_hostname\", None)\n        timeout = timeouts.get(\"connect\", None)\n    \n        retries_left = self._retries\n        delays = exponential_backoff(factor=RETRIES_BACKOFF_FACTOR)\n    \n        while True:\n            try:\n                if self._uds is None:\n                    kwargs = {\n                        \"host\": self._origin.host.decode(\"ascii\"),\n                        \"port\": self._origin.port,\n                        \"local_address\": self._local_address,\n                        \"timeout\": timeout,\n                        \"socket_options\": self._socket_options,\n                    }\n                    with Trace(\"connect_tcp\", logger, request, kwargs) as trace:\n                        stream = self._network_backend.connect_tcp(**kwargs)\n                        trace.return_value = stream\n                else:\n                    kwargs = {\n                        \"path\": self._uds,\n                        \"timeout\": timeout,\n                        \"socket_options\": self._socket_options,\n                    }\n                    with Trace(\n                        \"connect_unix_socket\", logger, request, kwargs\n                    ) as trace:\n                        stream = self._network_backend.connect_unix_socket(\n                            **kwargs\n                        )\n                        trace.return_value = stream\n    \n                if self._origin.scheme in (b\"https\", b\"wss\"):\n                    ssl_context = (\n                        default_ssl_context()\n                        if self._ssl_context is None\n                        else self._ssl_context\n                    )\n                    alpn_protocols = [\"http/1.1\", \"h2\"] if self._http2 else [\"http/1.1\"]\n                    ssl_context.set_alpn_protocols(alpn_protocols)\n    \n                    kwargs = {\n                        \"ssl_context\": ssl_context,\n                        \"server_hostname\": sni_hostname\n                        or self._origin.host.decode(\"ascii\"),\n                        \"timeout\": timeout,\n                    }\n                    with Trace(\"start_tls\", logger, request, kwargs) as trace:\n>                       stream = stream.start_tls(**kwargs)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_sync/connection.py:156: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore._backends.sync.SyncStream object at 0x7f6d1cf7d0f0>\nssl_context = <truststore._api.SSLContext object at 0x7f6d1d2b6040>\nserver_hostname = 'localhost', timeout = 60\n\n    def start_tls(\n        self,\n        ssl_context: ssl.SSLContext,\n        server_hostname: str | None = None,\n        timeout: float | None = None,\n    ) -> NetworkStream:\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n>       with map_exceptions(exc_map):\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_backends/sync.py:154: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7f6d1cf7d390>\ntyp = <class 'ssl.SSLCertVerificationError'>\nvalue = SSLCertVerificationError(1, '[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)')\ntraceback = <traceback object at 0x7f6d1e652ec0>\n\n    def __exit__(self, typ, value, traceback):\n        if typ is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = typ()\n            try:\n>               self.gen.throw(typ, value, traceback)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/contextlib.py:153: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmap = {<class 'TimeoutError'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE786\n            for from_exc, to_exc in map.items():\n                if isinstance(exc, from_exc):\n>                   raise to_exc(exc) from exc\nE                   httpcore.ConnectError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpcore/_exceptions.py:14: ConnectError\n\nThe above exception was the direct cause of the following exception:\n\nconnection = <firebolt.db.connection.Connection object at 0x7f6d1d2e3c30>\n\n    def test_parameterized_query(connection: Connection) -> None:\n        \"\"\"Query parameters are handled properly.\"\"\"\n    \n        def test_empty_query(c: Cursor, query: str, params: tuple) -> None:\n            assert c.execute(query, params) == 0, \"Invalid row count returned\"\n            assert c.rowcount == 0, \"Invalid rowcount value\"\n            assert c.description == [], \"Invalid description\"\n            assert c.fetchone() is None\n            assert len(c.fetchmany()) == 0\n            assert len(c.fetchall()) == 0\n    \n        with connection.cursor() as c:\n>           c.execute('DROP TABLE IF EXISTS \"test_tb_parameterized\"')\n\ntests/integration/dbapi/sync/V2/test_queries.py:242: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/common/cursor/decorators.py:24: in inner\n    return func(self, *args, **kwargs)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:338: in execute\n    self._do_execute(query, params_list, skip_parsing, timeout=timeout_seconds)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:238: in _do_execute\n    self._execute_single_query(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:265: in _execute_single_query\n    self._handle_query_execution(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:289: in _handle_query_execution\n    resp = self._api_request(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/db/cursor.py:159: in _api_request\n    return self._client.send(req, stream=True)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:926: in send\n    response = self._send_handling_auth(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:954: in _send_handling_auth\n    response = self._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/firebolt/client/client.py:123: in _send_handling_redirects\n    return super()._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:991: in _send_handling_redirects\n    response = self._send_single_request(request)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_client.py:1027: in _send_single_request\n    response = transport.handle_request(request)\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:235: in handle_request\n    with map_httpcore_exceptions():\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/contextlib.py:153: in __exit__\n    self.gen.throw(typ, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:\n            mapped_exc = None\n    \n            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():\n                if not isinstance(exc, from_exc):\n                    continue\n                # We want to map to the most specific exception we can find.\n                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to\n                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.\n                if mapped_exc is None or issubclass(to_exc, mapped_exc):\n                    mapped_exc = to_exc\n    \n            if mapped_exc is None:  # pragma: no cover\n                raise\n    \n            message = str(exc)\n>           raise mapped_exc(message) from exc\nE           httpx.ConnectError: [SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed: unable to get local issuer certificate (_ssl.c:1017)\n\n/opt/hostedtoolcache/Python/3.10.18/x64/lib/python3.10/site-packages/httpx/_transports/default.py:89: ConnectError","flaky":false,"newFailed":false,"newBroken":false,"newPassed":false,"retriesCount":1,"retriesStatusChange":true,"beforeStages":[{"name":"service_secret","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"database_name","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"engine_name","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"service_id","time":{"start":1751992252368,"stop":1751992252368,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"auth","time":{"start":1751992252368,"stop":1751992252436,"duration":68},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"api_endpoint","time":{"start":1751992252436,"stop":1751992252436,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_url","time":{"start":1751992252436,"stop":1751992252437,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"core_auth","time":{"start":1751992252436,"stop":1751992252436,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"account_name","time":{"start":1751992252436,"stop":1751992252436,"duration":0},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false},{"name":"connection","time":{"start":1751992254853,"stop":1751992254857,"duration":4},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"afterStages":[{"name":"connection::0","time":{"start":1751992255062,"stop":1751992255063,"duration":1},"status":"passed","steps":[],"attachments":[],"parameters":[],"shouldDisplayMessage":false,"stepsCount":0,"attachmentsCount":0,"hasContent":false,"attachmentStep":false}],"labels":[{"name":"parentSuite","value":"tests.integration.dbapi.sync.V2"},{"name":"suite","value":"test_queries"},{"name":"host","value":"pkrvmbietmlfzoi"},{"name":"thread","value":"3786-MainThread"},{"name":"framework","value":"pytest"},{"name":"language","value":"cpython3"},{"name":"package","value":"tests.integration.dbapi.sync.V2.test_queries"},{"name":"resultFormat","value":"allure2"}],"parameters":[{"name":"connection","value":"'core'"}],"links":[],"hidden":false,"retry":false,"extra":{"severity":"normal","retries":[{"uid":"dc89a7dc44897dee","status":"passed","time":{"start":1751992247938,"stop":1751992247998,"duration":60}}],"categories":[{"name":"Test defects","matchedStatuses":[],"flaky":false}],"tags":[]},"source":"4717e24cd961d205.json","parameterValues":["'core'"]}