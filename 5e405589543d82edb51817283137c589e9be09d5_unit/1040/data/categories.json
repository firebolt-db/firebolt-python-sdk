{
  "uid" : "4b4757e66a1912dae1a509f688f20b0f",
  "children" : [ {
    "name" : "Product defects",
    "children" : [ {
      "name" : "AssertionError: Expected class DatabaseService(BaseService):\n    def get(self, id_: str) -> Database:\n        \"\"\"Get a Database from Firebolt by its ID.\"\"\"\n\n        response = self.client.get(\n            url=ACCOUNT_DATABASE_URL.format(account_id=self.account_id, database_id=id_)\n        )\n        return Database.parse_obj_with_service(\n            obj=response.json()[\"database\"], database_service=self\n        )\n\n    def get_by_name(self, name: str) -> Database:\n        \"\"\"Get a database from Firebolt by its name.\"\"\"\n\n        database_id = self.get_id_by_name(name=name)\n        return self.get(id_=database_id)\n\n    def get_id_by_name(self, name: str) -> str:\n        \"\"\"Get a database ID from Firebolt by its name.\"\"\"\n\n        response = self.client.get(\n            url=ACCOUNT_DATABASE_BY_NAME_URL.format(account_id=self.account_id),\n            params={\"database_name\": name},\n        )\n        database_id = response.json()[\"database_id\"][\"database_id\"]\n        return database_id\n\n    def get_many(\n        self,\n        name_contains: Optional[str] = None,\n        attached_engine_name_eq: Optional[str] = None,\n        attached_engine_name_contains: Optional[str] = None,\n        order_by: Optional[Union[str, DatabaseOrder]] = None,\n    ) -> List[Database]:\n        \"\"\"\n        Get a list of databases on Firebolt.\n\n        Args:\n            name_contains: Filter for databases with a name containing this substring\n            attached_engine_name_eq: Filter for databases by an exact engine name\n            attached_engine_name_contains: Filter for databases by engines with a\n                name containing this substring\n            order_by: Method by which to order the results.\n                See :py:class:`firebolt.service.types.DatabaseOrder`\n\n        Returns:\n            A list of databases matching the filters\n        \"\"\"\n\n        if isinstance(order_by, str):\n            order_by = DatabaseOrder[order_by].name\n\n        params = {\n            \"page.first\": \"1000\",\n            \"order_by\": order_by,\n            \"filter.name_contains\": name_contains,\n            \"filter.attached_engine_name_eq\": attached_engine_name_eq,\n            \"filter.attached_engine_name_contains\": attached_engine_name_contains,\n        }\n\n        response = self.client.get(\n            url=ACCOUNT_DATABASES_URL.format(account_id=self.account_id),\n            params=prune_dict(params),\n        )\n\n        return [\n            Database.parse_obj_with_service(obj=d[\"node\"], database_service=self)\n            for d in response.json()[\"edges\"]\n        ]\n\n    def create(\n        self, name: str, region: Optional[str] = None, description: Optional[str] = None\n    ) -> Database:\n        \"\"\"\n        Create a new Database on Firebolt.\n\n        Args:\n            name: Name of the database\n            region: Region name in which to create the database\n\n        Returns:\n            The newly created database\n        \"\"\"\n\n        class _DatabaseCreateRequest(FireboltBaseModel):\n            \"\"\"Helper model for sending database creation requests.\"\"\"\n\n            account_id: str\n            database: Database\n\n        if region is None:\n            region_key = self.resource_manager.regions.default_region.key\n        else:\n            region_key = self.resource_manager.regions.get_by_name(name=region).key\n        database = Database(\n            name=name, compute_region_key=region_key, description=description\n        )\n\n        logger.info(f\"Creating Database (name={name})\")\n        response = self.client.post(\n            url=ACCOUNT_DATABASES_URL.format(account_id=self.account_id),\n            headers={\"Content-type\": \"application/json\"},\n            json=_DatabaseCreateRequest(\n                account_id=self.account_id,\n                database=database,\n            ).jsonable_dict(by_alias=True),\n        )\n        return Database.parse_obj_with_service(\n            obj=response.json()[\"database\"], database_service=self\n        )\n, got class DatabaseService(BaseService):\n    def get(self, id_: str) -> Database:\n        \"\"\"Get a Database from Firebolt by its ID.\"\"\"\n\n        response = self.client.get(\n            url=ACCOUNT_DATABASE_URL.format(account_id=self.account_id, database_id=id_)\n        )\n        return Database.parse_obj_with_service(\n            obj=response.json()[\"database\"], database_service=self\n        )\n\n    def get_by_name(self, name: str) -> Database:\n        \"\"\"Get a database from Firebolt by its name.\"\"\"\n\n        database_id = self.get_id_by_name(name=name)\n        return self.get(id_=database_id)\n\n    def get_id_by_name(self, name: str) -> str:\n        \"\"\"Get a database ID from Firebolt by its name.\"\"\"\n\n        response = self.client.get(\n            url=ACCOUNT_DATABASE_BY_NAME_URL.format(account_id=self.account_id),\n            params={\"database_name\": name},\n        )\n        database_id = response.json()[\"database_id\"][\"database_id\"]\n        return database_id\n\n    def get_many(\n        self,\n        name_contains: Optional[str] = None,\n        attached_engine_name_eq: Optional[str] = None,\n        attached_engine_name_contains: Optional[str] = None,\n        order_by: Optional[Union[str, DatabaseOrder]] = None,\n    ) -> List[Database]:\n        \"\"\"\n        Get a list of databases on Firebolt.\n\n        Args:\n            name_contains: Filter for databases with a name containing this substring\n            attached_engine_name_eq: Filter for databases by an exact engine name\n            attached_engine_name_contains: Filter for databases by engines with a\n                name containing this substring\n            order_by: Method by which to order the results.\n                See :py:class:`firebolt.service.types.DatabaseOrder`\n\n        Returns:\n            A list of databases matching the filters\n        \"\"\"\n\n        if isinstance(order_by, str):\n            order_by = DatabaseOrder[order_by].name\n\n        params = {\n            \"page.first\": \"1000\",\n            \"order_by\": order_by,\n            \"filter.name_contains\": name_contains,\n            \"filter.attached_engine_name_eq\": attached_engine_name_eq,\n            \"filter.attached_engine_name_contains\": attached_engine_name_contains,\n        }\n\n        response = self.client.get(\n            url=ACCOUNT_DATABASES_URL.format(account_id=self.account_id),\n            params=prune_dict(params),\n        )\n\n        return [\n            Database.parse_obj_with_service(obj=d[\"node\"], database_service=self)\n            for d in response.json()[\"edges\"]\n        ]\n\n    def create(\n        self, name: str, region: Optional[str] = None, description: Optional[str] = None\n    ) -> Database:\n        \"\"\"\n        Create a new Database on Firebolt.\n\n        Args:\n            name: Name of the database\n            region: Region name in which to create the database\n\n        Returns:\n            The newly created database\n        \"\"\"\n\n        class _DatabaseCreateRequest(FireboltBaseModel):\n            \"\"\"Helper model for sending database creation requests.\"\"\"\n\n            account_id: str\n            database: Database\n\n        if region is None:\n            region_key = self.resource_manager.regions.default_region.key\n        else:\n            region_key = self.resource_manager.regions.get_by_name(name=region).key\n        database = Database(\n            name=name, compute_region_key=region_key, description=description\n        )\n\n        logger.info(f\"Creating Database (name={name})\")\n        response = self.client.post(\n            url=ACCOUNT_DATABASES_URL.format(account_id=self.account_id),\n            headers={\"Content-type\": \"application/json\"},\n            json=_DatabaseCreateRequest(\n                account_id=self.account_id,\n                database=database,\n            ).jsonable_dict(by_alias=True),\n        )\n        return Database.parse_obj_with_service(\n            obj=response.json()[\"database\"], database_service=self\n        )\n(False), (False)",
      "children" : [ {
        "name" : "test_create_binding_existing_db",
        "uid" : "820c26c7aad36c30",
        "parentUid" : "4c36d171c4c704d9b4d760487e44dc2e",
        "status" : "failed",
        "time" : {
          "start" : 1705916191852,
          "stop" : 1705916191912,
          "duration" : 60
        },
        "flaky" : false,
        "newFailed" : true,
        "parameters" : [ ]
      } ],
      "uid" : "4c36d171c4c704d9b4d760487e44dc2e"
    } ],
    "uid" : "8fb3a91ba5aaf9de24cc8a92edc82b5d"
  } ],
  "name" : "categories"
}