{
  "uid" : "4ca1d7bb637424fa",
  "name" : "test_disallowed_set_parameter[account_id]",
  "fullName" : "tests.unit.db.V1.test_cursor#test_disallowed_set_parameter",
  "historyId" : "c4e4712fca04c4830cf12bcb10b32ed9",
  "time" : {
    "start" : 1711637898944,
    "stop" : 1711637899191,
    "duration" : 247
  },
  "description" : "Test that setting disallowed parameters raises an error.",
  "descriptionHtml" : "<p>Test that setting disallowed parameters raises an error.</p>\n",
  "status" : "broken",
  "statusMessage" : "httpx.ConnectError: [Errno -2] Name or service not known",
  "statusTrace" : "map = {<class 'socket.timeout'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_exceptions.py:10: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.OverriddenHttpBackend object at 0x7ff01915d160>\nhost = 'api-dev.mock.firebolt.io', port = 443, timeout = None\nlocal_address = None, socket_options = []\n\n    def connect_tcp(\n        self,\n        host: str,\n        port: int,\n        timeout: typing.Optional[float] = None,\n        local_address: typing.Optional[str] = None,\n        socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,\n    ) -> NetworkStream:\n        # Note that we automatically include `TCP_NODELAY`\n        # in addition to any other custom socket options.\n        if socket_options is None:\n            socket_options = []  # pragma: no cover\n        address = (host, port)\n        source_address = None if local_address is None else (local_address, 0)\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n    \n        with map_exceptions(exc_map):\n>           sock = socket.create_connection(\n                address,\n                timeout,\n                source_address=source_address,\n            )\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_backends/sync.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('api-dev.mock.firebolt.io', 443), timeout = None\nsource_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        A host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n>       for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/socket.py:787: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nhost = 'api-dev.mock.firebolt.io', port = 443, family = 0\ntype = <SocketKind.SOCK_STREAM: 1>, proto = 0, flags = 0\n\n    def getaddrinfo(host, port, family=0, type=0, proto=0, flags=0):\n        \"\"\"Resolve host and port into list of address info entries.\n    \n        Translate the host/port argument into a sequence of 5-tuples that contain\n        all the necessary arguments for creating a socket connected to that service.\n        host is a domain name, a string representation of an IPv4/v6 address or\n        None. port is a string service name such as 'http', a numeric port number or\n        None. By passing None as the value of host and port, you can pass NULL to\n        the underlying C API.\n    \n        The family, type and proto arguments can be optionally specified in order to\n        narrow the list of addresses returned. Passing zero as a value for each of\n        these arguments selects the full range of results.\n        \"\"\"\n        # We override this function since we want to translate the numeric family\n        # and socket type values to enum constants.\n        addrlist = []\n>       for res in _socket.getaddrinfo(host, port, family, type, proto, flags):\nE       socket.gaierror: [Errno -2] Name or service not known\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/socket.py:918: gaierror\n\nThe above exception was the direct cause of the following exception:\n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n>           yield\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:60: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.KeepaliveTransport object at 0x7ff01915d640>\nrequest = <AuthRequest('POST', 'https://api-dev.mock.firebolt.io/auth/v1/login')>\n\n    def handle_request(\n        self,\n        request: Request,\n    ) -> Response:\n        assert isinstance(request.stream, SyncByteStream)\n    \n        req = httpcore.Request(\n            method=request.method,\n            url=httpcore.URL(\n                scheme=request.url.raw_scheme,\n                host=request.url.raw_host,\n                port=request.url.port,\n                target=request.url.raw_path,\n            ),\n            headers=request.headers.raw,\n            content=request.stream,\n            extensions=request.extensions,\n        )\n        with map_httpcore_exceptions():\n>           resp = self._pool.handle_request(req)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:218: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.ConnectionPool object at 0x7ff01915dbb0>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        status = RequestStatus(request)\n    \n        with self._pool_lock:\n            self._requests.append(status)\n            self._close_expired_connections()\n            self._attempt_to_acquire_connection(status)\n    \n        while True:\n            timeouts = request.extensions.get(\"timeout\", {})\n            timeout = timeouts.get(\"pool\", None)\n            try:\n                connection = status.wait_for_connection(timeout=timeout)\n            except BaseException as exc:\n                # If we timeout here, or if the task is cancelled, then make\n                # sure to remove the request from the queue before bubbling\n                # up the exception.\n                with self._pool_lock:\n                    # Ensure only remove when task exists.\n                    if status in self._requests:\n                        self._requests.remove(status)\n                    raise exc\n    \n            try:\n                response = connection.handle_request(request)\n            except ConnectionNotAvailable:\n                # The ConnectionNotAvailable exception is a special case, that\n                # indicates we need to retry the request on a new connection.\n                #\n                # The most common case where this can occur is when multiple\n                # requests are queued waiting for a single connection, which\n                # might end up as an HTTP/2 connection, but which actually ends\n                # up as HTTP/1.1.\n                with self._pool_lock:\n                    # Maintain our position in the request queue, but reset the\n                    # status so that the request becomes queued again.\n                    status.unset_connection()\n                    self._attempt_to_acquire_connection(status)\n            except BaseException as exc:\n                with ShieldCancellation():\n                    self.response_closed(status)\n>               raise exc\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection_pool.py:262: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <httpcore.ConnectionPool object at 0x7ff01915dbb0>\nrequest = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        \"\"\"\n        Send an HTTP request, and return an HTTP response.\n    \n        This is the core implementation that is called into by `.request()` or `.stream()`.\n        \"\"\"\n        scheme = request.url.scheme.decode()\n        if scheme == \"\":\n            raise UnsupportedProtocol(\n                \"Request URL is missing an 'http://' or 'https://' protocol.\"\n            )\n        if scheme not in (\"http\", \"https\", \"ws\", \"wss\"):\n            raise UnsupportedProtocol(\n                f\"Request URL has an unsupported protocol '{scheme}://'.\"\n            )\n    \n        status = RequestStatus(request)\n    \n        with self._pool_lock:\n            self._requests.append(status)\n            self._close_expired_connections()\n            self._attempt_to_acquire_connection(status)\n    \n        while True:\n            timeouts = request.extensions.get(\"timeout\", {})\n            timeout = timeouts.get(\"pool\", None)\n            try:\n                connection = status.wait_for_connection(timeout=timeout)\n            except BaseException as exc:\n                # If we timeout here, or if the task is cancelled, then make\n                # sure to remove the request from the queue before bubbling\n                # up the exception.\n                with self._pool_lock:\n                    # Ensure only remove when task exists.\n                    if status in self._requests:\n                        self._requests.remove(status)\n                    raise exc\n    \n            try:\n>               response = connection.handle_request(request)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection_pool.py:245: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        with self._request_lock:\n            if self._connection is None:\n                try:\n                    stream = self._connect(request)\n    \n                    ssl_object = stream.get_extra_info(\"ssl_object\")\n                    http2_negotiated = (\n                        ssl_object is not None\n                        and ssl_object.selected_alpn_protocol() == \"h2\"\n                    )\n                    if http2_negotiated or (self._http2 and not self._http1):\n                        from .http2 import HTTP2Connection\n    \n                        self._connection = HTTP2Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                    else:\n                        self._connection = HTTP11Connection(\n                            origin=self._origin,\n                            stream=stream,\n                            keepalive_expiry=self._keepalive_expiry,\n                        )\n                except Exception as exc:\n                    self._connect_failed = True\n>                   raise exc\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection.py:92: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def handle_request(self, request: Request) -> Response:\n        if not self.can_handle_request(request.url.origin):\n            raise RuntimeError(\n                f\"Attempted to send request to {request.url.origin} on connection to {self._origin}\"\n            )\n    \n        with self._request_lock:\n            if self._connection is None:\n                try:\n>                   stream = self._connect(request)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection.py:69: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <HTTPConnection [CONNECTION FAILED]>, request = <Request [b'POST']>\n\n    def _connect(self, request: Request) -> NetworkStream:\n        timeouts = request.extensions.get(\"timeout\", {})\n        sni_hostname = request.extensions.get(\"sni_hostname\", None)\n        timeout = timeouts.get(\"connect\", None)\n    \n        retries_left = self._retries\n        delays = exponential_backoff(factor=RETRIES_BACKOFF_FACTOR)\n    \n        while True:\n            try:\n                if self._uds is None:\n                    kwargs = {\n                        \"host\": self._origin.host.decode(\"ascii\"),\n                        \"port\": self._origin.port,\n                        \"local_address\": self._local_address,\n                        \"timeout\": timeout,\n                        \"socket_options\": self._socket_options,\n                    }\n                    with Trace(\"connect_tcp\", logger, request, kwargs) as trace:\n>                       stream = self._network_backend.connect_tcp(**kwargs)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_sync/connection.py:117: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.OverriddenHttpBackend object at 0x7ff01915d160>\nargs = ()\nkwargs = {'host': 'api-dev.mock.firebolt.io', 'local_address': None, 'port': 443, 'socket_options': None, ...}\n\n    def connect_tcp(self, *args, **kwargs):  # type: ignore\n>       stream = super().connect_tcp(*args, **kwargs)\n\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/client/http_backend.py:62: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <firebolt.client.http_backend.OverriddenHttpBackend object at 0x7ff01915d160>\nhost = 'api-dev.mock.firebolt.io', port = 443, timeout = None\nlocal_address = None, socket_options = []\n\n    def connect_tcp(\n        self,\n        host: str,\n        port: int,\n        timeout: typing.Optional[float] = None,\n        local_address: typing.Optional[str] = None,\n        socket_options: typing.Optional[typing.Iterable[SOCKET_OPTION]] = None,\n    ) -> NetworkStream:\n        # Note that we automatically include `TCP_NODELAY`\n        # in addition to any other custom socket options.\n        if socket_options is None:\n            socket_options = []  # pragma: no cover\n        address = (host, port)\n        source_address = None if local_address is None else (local_address, 0)\n        exc_map: ExceptionMapping = {\n            socket.timeout: ConnectTimeout,\n            OSError: ConnectError,\n        }\n    \n        with map_exceptions(exc_map):\n>           sock = socket.create_connection(\n                address,\n                timeout,\n                source_address=source_address,\n            )\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_backends/sync.py:100: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x7ff016cbd610>\ntype = <class 'socket.gaierror'>\nvalue = gaierror(-2, 'Name or service not known')\ntraceback = <traceback object at 0x7ff018da59c0>\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n                next(self.gen)\n            except StopIteration:\n                return False\n            else:\n                raise RuntimeError(\"generator didn't stop\")\n        else:\n            if value is None:\n                # Need to force instantiation so we can reliably\n                # tell if we get the same exception back\n                value = type()\n            try:\n>               self.gen.throw(type, value, traceback)\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/contextlib.py:131: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmap = {<class 'socket.timeout'>: <class 'httpcore.ConnectTimeout'>, <class 'OSError'>: <class 'httpcore.ConnectError'>}\n\n    @contextlib.contextmanager\n    def map_exceptions(map: ExceptionMapping) -> Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE786\n            for from_exc, to_exc in map.items():\n                if isinstance(exc, from_exc):\n>                   raise to_exc(exc) from exc\nE                   httpcore.ConnectError: [Errno -2] Name or service not known\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpcore/_exceptions.py:14: ConnectError\n\nThe above exception was the direct cause of the following exception:\n\ncursor = <firebolt.db.cursor.CursorV1 object at 0x7ff0181ef460>\nparameter = 'account_id'\n\n    @mark.parametrize(\n        \"parameter\",\n        [\n            \"database\",\n            \"engine\",\n            \"account_id\",\n            \"output_format\",\n        ],\n    )\n    def test_disallowed_set_parameter(cursor: Cursor, parameter: str) -> None:\n        \"\"\"Test that setting disallowed parameters raises an error.\"\"\"\n        with raises(ConfigurationError) as e:\n>           cursor.execute(f\"SET {parameter}=dummy\")\n\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/tests/unit/db/V1/test_cursor.py:755: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/common/base_cursor.py:136: in inner\n    return func(self, *args, **kwargs)\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/db/cursor.py:279: in execute\n    self._do_execute(query, params_list, skip_parsing, async_execution)\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/db/cursor.py:198: in _do_execute\n    self._validate_set_parameter(query)\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/db/cursor.py:134: in _validate_set_parameter\n    resp = self._api_request(\"select 1\", {parameter.name: parameter.value})\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/db/cursor.py:527: in _api_request\n    return self._client.request(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:814: in request\n    return self.send(request, auth=auth, follow_redirects=follow_redirects)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:901: in send\n    response = self._send_handling_auth(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:929: in _send_handling_auth\n    response = self._send_handling_redirects(\n/home/runner/work/firebolt-python-sdk/firebolt-python-sdk/src/firebolt/client/client.py:308: in _send_handling_redirects\n    return super()._send_handling_redirects(\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:966: in _send_handling_redirects\n    response = self._send_single_request(request)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_client.py:1002: in _send_single_request\n    response = transport.handle_request(request)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:218: in handle_request\n    resp = self._pool.handle_request(req)\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/contextlib.py:131: in __exit__\n    self.gen.throw(type, value, traceback)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n    @contextlib.contextmanager\n    def map_httpcore_exceptions() -> typing.Iterator[None]:\n        try:\n            yield\n        except Exception as exc:  # noqa: PIE-786\n            mapped_exc = None\n    \n            for from_exc, to_exc in HTTPCORE_EXC_MAP.items():\n                if not isinstance(exc, from_exc):\n                    continue\n                # We want to map to the most specific exception we can find.\n                # Eg if `exc` is an `httpcore.ReadTimeout`, we want to map to\n                # `httpx.ReadTimeout`, not just `httpx.TimeoutException`.\n                if mapped_exc is None or issubclass(to_exc, mapped_exc):\n                    mapped_exc = to_exc\n    \n            if mapped_exc is None:  # pragma: no cover\n                raise\n    \n            message = str(exc)\n>           raise mapped_exc(message) from exc\nE           httpx.ConnectError: [Errno -2] Name or service not known\n\n/opt/hostedtoolcache/Python/3.8.18/x64/lib/python3.8/site-packages/httpx/_transports/default.py:77: ConnectError",
  "flaky" : false,
  "newFailed" : false,
  "beforeStages" : [ {
    "name" : "connection",
    "time" : {
      "start" : 1711637898876,
      "stop" : 1711637898942,
      "duration" : 66
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "password",
    "time" : {
      "start" : 1711637898838,
      "stop" : 1711637898838,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "username_password_auth",
    "time" : {
      "start" : 1711637898839,
      "stop" : 1711637898876,
      "duration" : 37
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "global_fake_fs",
    "time" : {
      "start" : 1711637898835,
      "stop" : 1711637898838,
      "duration" : 3
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "cursor",
    "time" : {
      "start" : 1711637898942,
      "stop" : 1711637898942,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "user",
    "time" : {
      "start" : 1711637898838,
      "stop" : 1711637898838,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "server",
    "time" : {
      "start" : 1711637898838,
      "stop" : 1711637898838,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "db_name",
    "time" : {
      "start" : 1711637898838,
      "stop" : 1711637898838,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  } ],
  "afterStages" : [ {
    "name" : "connection::0",
    "time" : {
      "start" : 1711637899439,
      "stop" : 1711637899439,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  }, {
    "name" : "global_fake_fs::0",
    "time" : {
      "start" : 1711637899442,
      "stop" : 1711637899442,
      "duration" : 0
    },
    "status" : "passed",
    "steps" : [ ],
    "attachments" : [ ],
    "parameters" : [ ],
    "stepsCount" : 0,
    "attachmentsCount" : 0,
    "shouldDisplayMessage" : false,
    "hasContent" : false
  } ],
  "labels" : [ {
    "name" : "parentSuite",
    "value" : "tests.unit.db.V1"
  }, {
    "name" : "suite",
    "value" : "test_cursor"
  }, {
    "name" : "host",
    "value" : "fv-az692-845"
  }, {
    "name" : "thread",
    "value" : "2338-MainThread"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "package",
    "value" : "tests.unit.db.V1.test_cursor"
  }, {
    "name" : "resultFormat",
    "value" : "allure2"
  } ],
  "parameters" : [ {
    "name" : "parameter",
    "value" : "'account_id'"
  } ],
  "links" : [ ],
  "hidden" : false,
  "retry" : false,
  "extra" : {
    "severity" : "normal",
    "retries" : [ ],
    "categories" : [ {
      "name" : "Test defects",
      "matchedStatuses" : [ ],
      "flaky" : false
    } ],
    "tags" : [ ]
  },
  "source" : "4ca1d7bb637424fa.json",
  "parameterValues" : [ "'account_id'" ]
}